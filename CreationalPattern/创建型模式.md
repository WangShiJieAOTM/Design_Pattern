# 创建型模式

创建型模式提供了创建对象的机制,能够提升已有代码的灵活性和可复用性

### 工厂模式(Factory Pattern)

在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型

#### 适用的场景:

1.无法预知对象确切类别及其依赖关系时,可使用工厂方法模式

```
如果需要向应用中添加新产品,你只需要开发新的创建者子类,然后重写其工厂方法即可
```

2.如果你希望用户能扩展你软件库或框架的内部组件,可使用工厂方法模式

```
比如你想要添加一个圆形的按钮UI组件,你可以创建一个新的创建者子类,然后重写其工厂方法,使其返回一个圆形的按钮对象
```

3.如果你希望复用现有对象来节省系统资源,而不是每次都创建对象,可使用工厂对象

```
比如你想要创建一个数据库连接对象,你可以创建一个单例的创建者子类,然后重写其工厂方法,使其返回一个数据库连接对象
```

#### 优点:

1.可以避免创建者和使用者之间的耦合

2.单一职责原则,每个创建者只负责创建一个对象,使得代码更容易维护

3.开闭原则,增加新的创建者子类,不需要修改现有代码

#### 缺点:

1.应用工厂方法模式需要引入额外的类,增加了系统的复杂度

### 抽象工厂模式(Abstract Factory Pattern)

#### 适用的场景:

1.如果代码需要与多个**不同系列**的相关产品交互,但是由于无法提前获取相关信息,或者出于对未来扩展性的考虑,你不希望代码基于产品的具体类进行构建,可使用抽象工厂模式

2.如果你有一个基于**一组**抽象方法的类,且其主要功能因此变得不明确,那么在这种情况下,你可以使用抽象工厂模式

#### 优点:

1.你可以确保同一工厂生成的产品相互匹配 2.你可以避免客户端和具体产品之间的耦合 3.单一职责原则,你可以将产品代码抽取到同一位置,使得代码更容易维护 4.开闭原则,增加新的产品变体时,不需要修改客户端代码

#### 缺点:

1.应用抽象工厂模式需要引入额外的类,增加了系统的复杂度

### 建造者模式(Builder Pattern)

生成器模式是一种创建型设计模式,可将复杂对象的构建与其表示分离,该模式允许你使用相同的构建代码才生成不同类型和形式的对象

#### 适用的场景:

1.使用生成器模式可避免 "重叠构造函数"的出现

```C++
class Pizza{
public:
Pizza(int size);
Pizza(int size, bool cheese);
Pizza(int size, bool cheese, bool pepperoni);
};
```

2.当你希望使用代码创建不同形式的产品(例如石头或木头房屋)时,可使用生成器模式

3.使用生产器构造组合树或其他复杂对象(有未发布的功能只需要不在builder中构造即可)

#### 优点:

1.你可以分布构建对象,暂缓创建步骤或递归运行创建步骤

2.生成不同形式的产品时,你可以复用相同的创建代码

3.单一职责原则,你可以将复杂构造代码从产品的业务逻辑中分离出来

#### 缺点:

1.由于该模式需要新增多个类,因此会增加系统的复杂度

### 原型模式(Prototype Pattern)

原型模式也被称为 克隆模式 clone

原型是一种创建型设计模式,使你能够复制已有对象,而又无需使代码依赖它们所属的类\

#### 适用的场景:

1.如果你需要复制一些对象,同时又希望代码独立于这些对象的具体类,可以使用原型模式

通常出现在代码在处理第三方代码通过接口传递过来的对象时.因为不知道第三方代码的具体信息 原型模式为客户端代码提供一个通用接口,客户端可以通过这一接口实现克隆对象进行交互

2.如果子类的区别仅在与其对象的初始化方式,那么你可以使用该模式来减少子类的数量,别人创建这些子类的目的可能是为了创建特定类型的对象

客户端不需要根据需求对子类进行初始化,只需要找到合适的原型并对其进行克隆即可

#### 优点:

1.你可以克隆对象,而无需与他们所属的具体类相耦合

2.你可以克隆预生成的原型,避免反复运行初始化代码

3.你可以更方便地生成复杂对象

4.你可以用继承以外的方式来处理复杂对象的不同配置

#### 缺点:

1.克隆包含循环引用的复杂对象可能会非常麻烦

### 单例模式(Singleton)

单例模式是一种创建型设计模式,让你能够保证一个类只有一个实例,并且提供一个访问该实例的全局节点

#### 适用的场景:

1.如果程序中的某个类对于所有客户端只有一个可用的实例,可以使用单例模式

2.如果你需要更加严格地控制全局变量,可以使用单例模式

#### 优点:

1.你可以保证一个类只有一个实例

2.你获得了一个指向该实例的全局访问节点

3.仅在首次请求单例对象时对其进行初始化

#### 缺点:

1.违反了**单一职责原则**,该模式将两个不同的职责组合在了一个类中(创建对象和控制其生命周期)

2.单例模式可能掩盖不良设计,比如程序各组件之间的相互了解过多等

3.该模式在多线程环境下要进行特殊处理,避免多个线程多次创建单例对象

4.单例的客户端代码单元测试可能会比较困难,因为许多测试框架以基于继承的方式创建模拟对象, 由于单例类的构造函数是私有的,而且绝大部分语言无法重写静态方法.而且你还需要仔细考虑模拟单例的方法,要么干脆不编写测试代码,或者不使用单例模式



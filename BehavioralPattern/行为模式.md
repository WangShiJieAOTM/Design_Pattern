# 行为模式

### 责任链模式(Chain of Responsibility Pattern)

又称为职责链模式,命令链,CoR,Chain of Command,Chain of Responsibility

责任链模式是一种行为设计模式,允许你将请求沿着处理者链进行发送,收到请求后,每个处理者均可对请求进行处理,或传递给链上的下个处理者

#### 适用的场景:

1.当程序需要使用不同方式处理不同种类请求,而且请求类型和顺序预先未知时,可以使用责任链模式

2.当必须按顺序执行多个处理者时,可以使用责任链模式

3.如果所需处理者及其顺序必须在运行时进行改变,可以使用责任链模式

#### 优点:

1.你可以控制请求处理的顺序

2.单一职责原则,你可以对发起操作和执行操作的类进行解耦

3.开闭原则,你可以在不更改现有代码的情况下在程序中新增处理者

#### 缺点:

1.部分请求可能未被处理

### 命令模式(Command Pattern)

又称为动作模式,动作(Action)或事务(Transaction)

命令模式是一种行为设计模式,它可将请求转换为一个包含与请求相关的所有信息的独立对象.该转换让你能根据不同请求将方法参数化,延迟请求执行或将其放入队列,以及支持可撤销的操作

#### 适用的场景:

1.如果你需要通过操作来参数化对象,可使用命令模式

2.如果你想要将操作放入队列中,操作的执行或者远程操作执行操作,可使用命令模式

3.如果你想要实现操作回滚功能,可使用命令模式

#### 优点:

1.单一职责原则,你可以解耦触发和执行操作的类

2.开闭原则,你可以再不修改已有客户端代码的情况下在程序中创建新的命令

3.你可以实现撤销和恢复功能

4.你可以实现操作和延迟执行

5.你可以将一组简单命令组合成一个复杂命令

#### 缺点:

1.代码可能会变得更加复杂,因为你子发送者和接受者之间增加了一个全新的层次

### 迭代器模式(Iterator Pattern)

迭代器是一种行为设计模式,让你能在不暴露集合底层表现形式(列表,栈,和树等)的情况下遍历集合中的所有元素

#### 适用的场景:

1.当集合背后为复杂的数据结构,且你希望对客户端隐藏其复杂性时(出于使用便利性或安全性的考虑),可以使用迭代器模式

2.使用该模式可以减少程序中重复的遍历代码

3.如果你希望代码能够遍历不同的甚至是无法预知的数据结构,可以使用迭代器模式

#### 优点:

1.单一职责原则,通过将体积庞大的遍历算法代码抽取为独立的类,你可以对客户端代码和集合进行整理

2.开闭原则,你可以实现新型的集合和迭代器并将其传递给现有的代码,无需修改现有代码

3.你可以并行遍历同一个集合,因为每个迭代器对象都包含其自身的遍历状态

4.相似的,你可以暂停遍历并在需要时继续

#### 缺点:

1.如果你的程序只与简单的集合进行交互,应用该模式可能会矫枉过正

2.对于某些特殊集合,使用迭代器可能比直接遍历的效率低

### 中介者模式(Mediator Pattern)

又称为调解人,控制器,Intermediary,Controller,Mediator

中介者是一种行为设计模式,能够让你减少对象之间混乱无序的依赖关系,该模式会限制对象之间的直接交互,迫使他们通过一个中介者对象进行合作

#### 适用的场景:

1.当一些对象和其他对象紧密耦合以致难以对齐进行修改时,可以使用中介者模式

2.当组件因过于依赖其他组件而无法在不同应用中复用时,可使用中介者模式

3.如果为了能在不同场景下复用一些基本行为,导致你需要被迫创建大量组件子类时,可以使用中介者模式

#### 优点:

1.单一职责原则,你可以将多个组件间的交流抽取到同一位置,使其更加容易理解和维护

2.开闭原则,你无需修改实际组件就能增加新的中介者

3.你可以减轻应用中多个组件间的耦合情况

4.你可以更方便地复用各个组件

#### 缺点:

1.一段时间后,中介者可能会演化为上帝对象

### 备忘录模式(Memento Pattern)

又称为快照模式 Snapshot,Memento

备忘录是一种行为设计模式,允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态

#### 适用的场景:

1.当你需要创建对象状态快照来恢复其之前的状态时,可以使用备忘录模式

2.当直接访问对象的成员变量,获取器或设置其将导致封装被突破时,可以使用备忘录模式

#### 优点:

1.你可以在不破坏对象封装情况的前提下创建对象状态快照

2.你可以通过让负责人维护原发器状态历史记录来简化原发器代码

#### 缺点:

1.如果客户端过于频繁地创建备忘录,程序将消耗大量内存

2.负责人必须完整跟踪原发器的生命周期,这样才能销毁弃用的备忘录

3.绝大部分动态编程语言(如PHP/Python和Javascript)不能确保备忘录中的状态不被修改.

### 观察者模式(Observer Pattern)

又称为时间内订阅者、监听者、Event-Subscriber、Listener、Observer

观察者是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察者”对象

和ROS的话题机制很像

#### 适用的场景:

1.当一个对象状态的改变需要改变其他对象,或实际对象是实现位置的或动态变化的时,可以使用观察者模式

2.当应用中的一些对象必须观察其他对象时,可以使用该模式.但仅能在有限的时间内或特定情况下使用.

#### 优点:

1.开闭原则,你无需修改发布者代码就可以引入新的订阅者类(如果是发布者接口则可轻松引入发布者类)

2.你可以在运行时建立对象之间的联系

#### 缺点:

1.订阅者的通知顺序的随机的

### 状态模式(State Pattern)

状态模式是一种行为设计模式,让你能在一个对象的内部状态变化时改变其行为,使其看上去就像改变了自身所属的类一样

#### 适用的场景:

1.如果对象需要根据自身当前状态进行不同行为,同时状态的数量非常多且与状态相关的代码会频繁变更的话,可使用状态模式

2.如果某个类需要根据成员变量的当前值改变自身行为,从而需要使用大量的条件语句时,可使用该模式

3.当相似状态和基于条件的状态机转换中存在许多重复代码时,可以使用状态模式

#### 优点:

1.单一职责原则,将与特定状态相关的代码放在单独的类中

2.开闭原则,无需修改已有的状态类和上下文就能引入新状态

3.通过消除臃肿的状态机条件语句简化上下文代码

#### 缺点:

1.如果状态机只有很少的几个状态,或者很少发生改变,那么应用该模式可能会显得小题大做

### 策略模式(Strategy Pattern)

策略模式是一种行为设计模式,他能让你定义一系列算法,并将每种算法分别放入独立的类中,以使算法对象能够相互替换

#### 适用的场景:

1.当你想使用对象中各种不同的算法变体,并希望能在运行时切换算法时,可使用策略模式

2.当你有许多仅在执行某些行为时略有不同的相似类时,可使用策略模式

3.如果算法在上下文的逻辑中不是特别重要,使用该模式能将类的业务逻辑与其算法实现细节隔离开来

4.当类中使用了复杂条件运算符以在同意算法的不同变体中切换时,可使用该模式

#### 优点:

1.你可以在运行时切换对象内的算法

2.你可以将算法的实现和使用算法的代码隔离开来

3.你可以使用组合来代替继承

4.开闭原则,你无需对上下文进行修改就能够引入新的策略

#### 缺点:

1.如果你的算法极少发射管改变,那么没有任何理由引入新的类和接口,使用该模式只会让程序过于复杂

2.客户端必须知晓策略间的不同--他需要选择合适的策略

3.许多现代编程语言支持函数类型功能,允许你在一组匿名函数中实现不同版本的算法,这样,你使用这些函数的方式就和使用策略对象时完全相同,无需借助额外的类和接口来保持代码简洁

### 模板方法模式(Template Method Pattern)

模板方法是一种行为设计模式,他在超类中定义一个算法的框架,允许子类在不修改结构的情况下重写算法的特定步骤

#### 适用的场景:

1.当你只希望客户端扩展某个特定算法步骤,而不是整个算法或其结构时,可以使用模板方法模式

2.当多个类的算法除一些细微不同之外几乎完全一样时,你可使用该模式,但其后果就,只要算法发生变化,你就可能需要修改所有的类

#### 优点:

1.你可仅允许客户端重写一个大型算法中的特定部分,使得算法其他部分修改对其所造成的影响减小

2.你可将重复代码提取到一个超类中

#### 缺点:

1.部分客户端可能会受到算法框架的限制

2.通过子类抑制默认步骤实现可能会导致违反**里氏替换原则**.

3.模板方法中的步骤越多,其维护工作就可能会越困难.

### 访问者模式(Visitor Pattern)

访问者模式是一种行为设计模式,他能将算法与其所作用的对象隔离开来

#### 适用的场景:

1.如果你需要对一个复杂对象结构(例如对象树)中的所有元素执行某些操作,可使用访问者模式

2.可使用访问者模式来亲历辅助行为的业务逻辑

3.当某个行为仅在类层次结构中的一些类中有意义,而在其他类中没有意义时,可使用该模式

#### 优点:

1.开闭原则,你可以引入在不听类对象上执行的新行为,且无需对这些类做出修改

2.单一职责原则,可将同一行为的不同版本移到同一个类中

3.访问者对象可以在与各种对象交互时收集一些有用的信息.当你想要遍历一些复杂的对象结构(例如对象树),并在结构中的每个对象上应用访问者时,这些信息可能会有所帮助

#### 缺点:

1.每次在元素层次结构中添加或移除一个类,你都要更新所有访问者

2.在访问者同某个元素进行交互式,他们可能没有访问元素私有成员变量和方法的必要权限
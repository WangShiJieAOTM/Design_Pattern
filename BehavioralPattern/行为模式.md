# 行为模式

### 责任链模式(Chain of Responsibility Pattern)

又称为职责链模式,命令链,CoR,Chain of Command,Chain of Responsibility

责任链模式是一种行为设计模式,允许你将请求沿着处理者链进行发送,收到请求后,每个处理者均可对请求进行处理,或传递给链上的下个处理者

#### 适用的场景:

1.当程序需要使用不同方式处理不同种类请求,而且请求类型和顺序预先未知时,可以使用责任链模式

2.当必须按顺序执行多个处理者时,可以使用责任链模式

3.如果所需处理者及其顺序必须在运行时进行改变,可以使用责任链模式

#### 优点:

1.你可以控制请求处理的顺序

2.单一职责原则,你可以对发起操作和执行操作的类进行解耦

3.开闭原则,你可以在不更改现有代码的情况下在程序中新增处理者

#### 缺点:

1.部分请求可能未被处理

### 命令模式(Command Pattern)

又称为动作模式,动作(Action)或事务(Transaction)

命令模式是一种行为设计模式,它可将请求转换为一个包含与请求相关的所有信息的独立对象.该转换让你能根据不同请求将方法参数化,延迟请求执行或将其放入队列,以及支持可撤销的操作

#### 适用的场景:

1.如果你需要通过操作来参数化对象,可使用命令模式

2.如果你想要将操作放入队列中,操作的执行或者远程操作执行操作,可使用命令模式

3.如果你想要实现操作回滚功能,可使用命令模式

#### 优点:

1.单一职责原则,你可以解耦触发和执行操作的类

2.开闭原则,你可以再不修改已有客户端代码的情况下在程序中创建新的命令

3.你可以实现撤销和恢复功能

4.你可以实现操作和延迟执行

5.你可以将一组简单命令组合成一个复杂命令

#### 缺点:

1.代码可能会变得更加复杂,因为你子发送者和接受者之间增加了一个全新的层次

### 迭代器模式(Iterator Pattern)

迭代器是一种行为设计模式,让你能在不暴露集合底层表现形式(列表,栈,和树等)的情况下遍历集合中的所有元素

#### 适用的场景:

1.当集合背后为复杂的数据结构,且你希望对客户端隐藏其复杂性时(出于使用便利性或安全性的考虑),可以使用迭代器模式

2.使用该模式可以减少程序中重复的遍历代码

3.如果你希望代码能够遍历不同的甚至是无法预知的数据结构,可以使用迭代器模式

#### 优点:

1.单一职责原则,通过将体积庞大的遍历算法代码抽取为独立的类,你可以对客户端代码和集合进行整理

2.开闭原则,你可以实现新型的集合和迭代器并将其传递给现有的代码,无需修改现有代码

3.你可以并行遍历同一个集合,因为每个迭代器对象都包含其自身的遍历状态

4.相似的,你可以暂停遍历并在需要时继续

#### 缺点:

1.如果你的程序只与简单的集合进行交互,应用该模式可能会矫枉过正

2.对于某些特殊集合,使用迭代器可能比直接遍历的效率低

### 中介者模式(Mediator Pattern)

又称为调解人,控制器,Intermediary,Controller,Mediator

中介者是一种行为设计模式,能够让你减少对象之间混乱无序的依赖关系,该模式会限制对象之间的直接交互,迫使他们通过一个中介者对象进行合作

#### 适用的场景:

1.当一些对象和其他对象紧密耦合以致难以对齐进行修改时,可以使用中介者模式

2.当组件因过于依赖其他组件而无法在不同应用中复用时,可使用中介者模式

3.如果为了能在不同场景下复用一些基本行为,导致你需要被迫创建大量组件子类时,可以使用中介者模式

#### 优点:

1.单一职责原则,你可以将多个组件间的交流抽取到同一位置,使其更加容易理解和维护

2.开闭原则,你无需修改实际组件就能增加新的中介者

3.你可以减轻应用中多个组件间的耦合情况

4.你可以更方便地复用各个组件

#### 缺点:

1.一段时间后,中介者可能会演化为上帝对象

### 备忘录模式(Memento Pattern)

又称为快照模式 Snapshot,Memento

备忘录是一种行为设计模式,允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态

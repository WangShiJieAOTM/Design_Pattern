# 结构型模式

### 适配器模式(Adapter Pattern)

也被称为封装器模式,Wrapper

适配器模式是一种结构型设计模式,他能使得接口不兼容的对象能够相互合作

#### 适用的场景:

1.当你希望使用某个类,但是其接口与其他代码不兼容时,可以使用适配器模式

2.如果你需要复用这样一些类,他们处于同一继承体系,并且他们又有了额外的一些共同的方法,但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性

#### 优点:

1.单一职责原则,你可以将接口或数据转换代码从主要业务逻辑中分离出来(实现数据转换并不是类的职责)

2.开闭原则,只要客户端代码通过接口与适配器进行交互,那么你就可以在不修改现有客户端代码的情况下,在程序中引入新的适配器类

#### 缺点:

1.代码整体复杂度增加,因为你需要新增一系列接口和类,又是直接更改服务类使其与其他代码兼容会更简单

### 桥接模式(Bridge Pattern)

桥接模式是一种结构型设计模式,可以将一个大类或一组紧密相关的类拆分成两个独立的层次结构,从而使两个层次结构可以独立地扩展.

#### 适用的场景:

1.如果你想要拆分或重组一个具有多重功能的庞杂类(例如能与多种数据库服务器进行交互的类),可以使用桥接模式

2.如果你希望在几个独立维度上扩展一个类,可以使用该模式

3.如果你需要在运行时切换不同实现方法,可以使用桥接模式

#### 优点:

1.你可以创建与平台无关的类和程序

2.客户端代码仅与高层抽象部分进行互动,不会接触到平台的详细信息

3.开闭原则,你可以新增抽象部分和实现部分,且他们之间不会互相影响

4.单一职责原则,抽象部分专注于处理高层逻辑,而实现部分则负责处理平台特定的细节

#### 缺点:

1.对高内聚的类使用该模式可能会让代码更加复杂

### 组合模式(Composite Pattern)

又称为对象树 Object Tree,Composite

组合模式是一种结构型设计模式,他能将对象组合成树形结构,并且能像使用独立对象一样使用他们

#### 适用的场景:

1.如果你需要实现树状对象结构,可以使用组合模式

2.如果你希望客户端代码以相同的方式处理简单和复杂元素,可以使用该模式

组合模式中定义的所有元素共用一个接口,在这一接口的帮助下,客户端不必在意其所用的对象的具体类

#### 优点:

1.可以利用多态和递归机制更方便地使用复杂树结构

2.开闭原则.无需修改现有的代码,你就可以在应用中添加新的元素,使其成为对象树的一部分

#### 缺点:

1.对于功能差异较大的类,提供公共接口或许会有困难,在特定情况下,他需要过度一般化组件接口,从而变得难以理解

### 装饰器模式(Decorator Pattern)

装饰器模式是一种结构型设计模式,允许你通过将对象放入包含行为的特殊封装对象来为原对象绑定新的行为

#### 适用的场景:

1.如果你希望在无需修改代码的情况下即可使用对象,可以使用装饰器模式,且希望运行时为对象新增额外的行为, 可以使用装饰模式

2.如果用继承来扩展对象的方案难以实现或者根本不可行,可以使用装饰器模式

如果有些变成语言使用final关键字来限制某个类的进一步扩展,父类最终类的已有行为的唯一方法就是使用装饰模式:
用封装器对其进行封装

#### 优点:

1.你无需创建新子类即可扩展对象的行为

2.你可以在运行时添加或删除对象的功能

3.你可以用多个装饰器封装对象来组合几种行为

4.单一职责原则,你可以将实现了许多不同行为的一个大类拆分为多个较小的类

#### 缺点:

1.在封装器栈中删除特定封装器比较困难

2.实现行为不受装饰器栈顺序影响的装饰比较困难

3.各层的初始化配置代码看上去可能会很糟糕

### 外观模式(Facade Pattern)

又称为门面模式

外观模式是一种结构设计模式,能为程序库,框架或其他复杂提供一个简单的接口

#### 适用的场景:

1.如果你需要指向一个复杂子系统的直接接口.且该接口的功能有限,则可以使用外观模式

2.如果需要将子系统组织为多层结构,可以使用外观模式

#### 优点:

1.你可以让自己的代码独立于复杂子系统

#### 缺点:

1.外观模式可能成为与程序中所有类都耦合的上帝对象(套中套大家都在用外观模式,一旦外观模式的类更改所有的类都需要更改)

### 享元模式(Flyweight Pattern)

也称为缓存,Cache,Flyweight

享元模式是一种结构型设计模式,他摒弃了在每一个对象中保存所有数据的方式,通过共享多个对象所共有的相同状态,让你能在有限的内存容量后载入更多对象

#### 适用的场景:

1.仅在程序必须支持大量对象且没有足够的内存是使用享元模式

#### 优点:

1.如果程序中有很多相似对象,那么你将可以节省大量内存

#### 缺点:

1.你可能需要牺牲执行速度来换取内存,因为他人每次调用享元方法时都需要重新计算部分场景数据

2.代码会更加复杂,团队中的新成员总是会问:"为什么要像这样拆分一个实体的状态呢?"

### 代理模式(Proxy Pattern)

代理模式是一种结构型设计模式,让你能够提供对象的替代品或其占位符.代理控制这对于原对象的访问,并允许在将请求提交给对象前后进行一些处理

#### 适用的场景:

1.延迟初始化(虚拟代理).如果你有一个偶尔使用的重量级服务对象,一直保持该对象运行会消耗系统资源时,可使用代理模式

2.访问控制(保护代理).如果你只希望特定客户端使用服务对象,这里的对象可以是操作系统中非常重要的部分 而客户端则是各种已启动的程序(包括恶意程序),此时可使用代理模式

3.本地执行远程服务(远程代理).如果你需要将一个对象的方法调用转换为网络消息,可使用代理模式

4.记录日志请求(日志记录代理).适用于当你需要保存对于服务对象的请求历史记录时.代理可以在向服务传递请求前进记录.

5.智能引用,可在没有客户端使用某个重量级对象时立即销毁该对象

#### 优点:

1.你可以在客户端毫无察觉的情况下控制服务对象

2.如果客户端对服务对象的生命周期没有特殊要求,你可以对生命周期进行管理

3.即使服务对象还未准备好或不存在,代码里也可以正常工作

4.开闭原则,你可以在不对服务或客户端做出修改的情况下创建新代理

#### 缺点:

1.代码可能会变得复杂,因为需要新建许多类

2.服务响应可能会延迟
